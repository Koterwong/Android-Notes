## 第一章：对象导论

### 封装

被隐藏（也即封装）的部分通常代表对象内部脆弱的部分，它们很容易被程序员所毁坏，因此将实现隐藏起来可以减少程序的bug。 

隐藏是通过访问控制修饰符（public、protected、包访问、private）来实现的。

访问控制的第一个存在原因就是让调用者无法直接触及他们不应该触及的部分，但从另一方面来看，其实这不失为一项服务，因为他们可以很容易地看出哪些东西对他们来说很重要，而哪些东西可能不关心；访问控制的第二个存在原因就是允许库设计者可以改变类的内部的工作方式而不用担心会影响到调用者。

### 继承

代码复用：复用是面向对象程序设计所提供最了不起的优点之一。

最简单的代码复用就是直接调用类的方法，此外，我们还可以将该类置于某个新类中，使它成为新类的属性成员。新的类也可由任意数量、任意类型的其他对象以任意可以实现新的类中想要功能的方式所组成，这种使用现有的类合成新的类方式称为组合复用。

组合复用带来了极大的灵活性，使得它能在运行时动态的修改其实现行为，但继承并不具备这样的灵活性，因为继承是在编译时期就已经确定其行为，在运行时期是不能修改的。

继承两种实现方式，第一种方式非常直接：直接在子类中添加新的方法，即扩展父类接口。第二种方式就是子类覆写父类方法，但不新增父类没有接口。

“is-a是一个”与“is-like-a像是一个”。继承时，我们使用第一种还是第二种方式呢？这可能引起争论：继承应该只覆盖基类的方法，而并不添加在基类中没有的新方法吗？如果这样做，就意味着子类与基类是完全相同的类型，因为它们具有完全相同的接口，结果可以用一个子类对象来完全替代一个基类对象，这可被认为是纯粹替代，通常称之为替代原则，这也是一种理想的方式，我们经常称这种情况下的子类与基类的关系是“is-a是一个”；有时必须在子类型中添加新的接口，这样也就扩展了接口，这个新的类型仍可以替代基类，但是这种替代并不完美，因为基类无法访问新添加的方法，这种情况下我们可以描述为“is-like-a像是一个”关系。

### 多态

一个非面向对象编程的编译器产生的函数调用会引起所谓的前期绑定，而向对象程序设计语言使用了后期绑定的概念。

方法的调用就是编译器将产生对一个具体函数名字的调用，前期绑定是在运行时将这个调用解析到将要被执行的代码的绝对地址。然而在OOP中，程序直到运行时才能够确定代码的地址，为了执行后期绑定，Java编译器使用了一小段特殊代码来替代绝对地址调用，这段代码使用对象中存储的信息来计算方法体的地址，根据这段特殊代码，每个对象都可以具有不同的行为表现。

在某些语言中，必须明确地声明某个方法具备后期绑定属性所带来的灵活性，如C++使用virtual关键字来实现，在默认情况下，C++不是动态绑定的，而在Java中，动态绑定是默认行为，不需要添加额外的关键字来实现多态。

### Java语言支持四种类型

接口（interface）、类（class）、数组（array）和基本类型（primitive）。前三种类型通常被称为引用类型（reference type），类实例和数组是对象（object），而基本类型的值则不是对象。类的成员（member）由它的域（field）、方法（method）、成员类（member class）和成员接口（member interface）组成。方法签名（signature）由它的名称和所有参数类型组成；签名不包括它的返回类型。

### 类与类之间的关系

类和类、类和接口、接口和接口之间有如下几种关系：泛化关系、实现关系、关联关系（聚合、合成）、依赖关系。

- 泛化：表示类与类之间的继承关系，使用extends关键字来表示。在图形上使用虚线三角形箭头表示。


- 实现：表示类与接口之间的实现关系，使用implements关键字来表示。在图形上使用实线三角形箭头表示。
- 关联：类与类之间的联接。关联可以是双向的，也可以是单向的，双向的关联可以有两个箭头或都没有箭头。单向的关联有一个箭头，表示关联的方向。在Java里，关联关系是使用实例变量实现的。在每一个关联的端点，还可以有一个基数，表时这一端的类可以有几个实例。常见的基数有：0..1（零个或者一个实例）、0..*或者*（没限制，可以是零）、1（只有一个实例）、1..*（至少有一个实例）。一个关联关系可以进一步确定为聚合与合成关系。在图形上使用实线的箭头表示。
- 聚合：是关联关系的一种，是强的关联关系，聚合是整体和个体之间的关系。关联与聚合仅仅从Java语法是上是分辨不出的，需要考察所涉及的类之间的逻辑关系。如果不确定是聚合关系，可以将之设置为关联关系。图形是在实线的箭头的尾部多一个空心菱形。
- 合成：是关联关系的一种，是比聚合关系强的关系。它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。整体消亡，则部分与消亡。图形是在实线的箭头的尾部多一个黑心菱形。
- 依赖：类与类之间的连接，依赖总是单向的。表示一个类依赖于另一个类的定义。一般而言，依赖关系在Java里体现为局部变量、方法的参数、以及对静态方法的调用。但如果对方出现在实例变量中，那关系就超过了依赖关系，而成了关联关系了。在图形上使用虚线的箭头表示。


## 第二章：一切都是对象

### 对象存放位置与生命周期

C++创建的对象可以存放在栈、静态存储区与堆（heap）中，放在栈中的对象用完后不需手动释放，会自动销毁，但放在堆中的对象需手动释放，栈中的对象所需空间与生命周期都是确定的，堆中的对象内存分配是动态的，在运行时才知道需要多少内存以及生命周期，如果说在堆上创建对象，编译器就会对它的生命周期一无所知，C++就需要以编程的方式来确定何时销毁对象，这可能因不正确处理而导致内存泄漏，而Java则提供了自动垃圾回收机制。

Java对象的创建采用了动态内存分配策略，即创建的对象都是放在堆中的。

### 数据内存分配

寄存器——位于处理器内部，这是最快的存储区，大小极其有限，一般不能直接控制，但C和C++允许你向编译器建议寄存器分配方式。

堆栈——位于通用RAM（随机访问存储器）中，堆栈指针向下移动，则分配新的内存；若向上移动，则释放内存。这是一种快速有效的分配方法，速度仅次于寄存器。创建程序时，Java系统必须知道存储在堆栈内所有项的确切生命周期，以便上下移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些Java数据存储于堆栈中（如对象引用），但是Java对象并不存储于其中。

堆——一种通用的内存池（也位于RAM区），用于存放所有的Java对象，堆不同于堆栈的好处是，编译器不需要知道存储的数据在堆里存活多长时间。因此，在堆栈分配存储有很大的灵活性。当然，这种灵活性导致了分配需要更多的时间，时间效率上不如堆栈。

常量存储：常量值通常直接存放到程序代码内部，这样做是安全的，因为它们永远不会被改变。

非RAM存储：数据可完全存活于程序之外，在没有运行机制时也可以存在，如持久化对象的存放。

JVM有两类存储区：常量缓冲池和方法区。常量缓冲池用于存储类名称、方法和字段名称以及串常量。方法区则用于存储Java方法的字节码。

Java字节码的执行有两种方式：

1. 即时编译方式：解释器先将字节码编译成机器码，然后再执行该机器码。
2. 解释执行方式：解释器通过每次解释并执行一小段代码来完成Java字节码程 序的所有操作。

通常采用的是第二种方法。由于JVM规格描述具有足够的灵活性，这使得将字节码翻译为机器代码的工作具有较高的效率。对于那些对运行速度要求较高的应用程序，解释器可将Java字节码即时编译为机器码，从而很好地保证了Java代码的可移植性和高性能。

### 基本类型

void属于基本类型，但只能用来修饰方法，不能用来修饰变量。

Java提供了两个用于高精度计算类：BigInteger和BigDecimal，大体属于“包装器类”范畴，但都没有对应的基本类型。

BigInteger支持任意精度的整数，可表示任何大小的整数值。

BigDecimal支持任意精度的定点数，例如，可以用它进行精确的货币计算。

### 引用与对象生存周期

```
{
   String s = new String("a string");
}
```

引用s在作用域终点就消失了，然而，s指向的String对象继续占据内存，最后由垃圾回收器回收。

### 方法签名

方法名和参数列表（合起来被称为“方法签名”）唯一地标识出某个方法。

### static修饰字段与方法的区别

一个static字段对每个对象来说都只有一份空间，而非static字段则是对每个对象都有一个存储空间，但是如果static作用于某个方法时，差别却没有那么大，static方法的一个重要的用法就是在不创建任何对象的前提下就可以调用它，这一点对定义main()方法很重要，该方法是运行时程序的一个入口。

