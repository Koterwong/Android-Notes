# 个人简历技术点问题总结 #

##技术点：掌握Android四大组件。

### Activity ###

> #### 1. 介绍Activity，Activity的生命周期。 ####

- 简单介绍：Activity是四大组件之一，一般的一个用户界面对应一个Acticity。它是Context的子类同时实现了window.callback和keyevent.callback,可以处理与窗体的交互事件。

- 生命周期：生命周期描述的是一个类 从创建(new出来)到死亡(垃圾回收)的过程中会执行的方法在这个过程中 会针对不同的生命阶段会调用不同的方法。

   Activity从创建到销毁有多种状态，从一种状态到另一种状态时会调用不同的回调方法，这些回调方法两两对应。

  1. onCreate() onDestroy() 
  2. onStop() onStart() 
  3. onResume() ,onPause()

- onRestart()方法，被stop的Acticity重新启动从onRestart方法开始生命周期。
- onStart()方法，可以将刷新数据的到onStart里面，这样就能保证用户每次看到的数据都是最新的。
- onPause(),多媒体播放，播放来电话，onPause()音量设置为0，记录视频播放的位置。
- onPostResume() 和 OnPostCreate()这两个生命周期的方法,实现类不能覆盖该方法，是有框架回调的。

>#### 2. Activity的跳转要执行那些方法？ #### 

   假设有两个activity,分别叫A,B ,当A(Activity)跳转到B（Activity）时, A 会调用 onPause()方法,然后B 调用onCreate() ,onStart(), OnResume() ,
1. 这个时候B覆盖了窗体, A会调用onStop()方法。 
2. 如果B呢 是个透明的,或者是对话框的样式, 就不会调用onStop()方法

> #### 3 两个Activity之间怎么传递数据？ ####

- 传递基本数据类型。	
- 传递对象:实现Serializable(把对象存放在文件上)，Parcelable(把对象存放在内存中，效率更高)
- 文件/网络数据
  intent.setData(Uri) 
  Uri.fromFile();  //大图片的传递

> #### 4. 横竖屏切换时候Activity的生命周期? ####

- 设置始终竖屏`android:screenOrientation="portrait"`
- a. 不设置Activity的android:configChanges时，切屏会重新调用各个生命周期
  默认首先销毁当前activity,然后重新加载。切横屏时会执行一次，切竖屏时会执行两次
- b. 设置Activity的android:configChanges="orientation"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次。
- c. 设置Activity的android:configChanges="orientation|keyboardHidden|screenSize"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法

> #### 5. 如何退出Activity？如何安全退出已调用多个Activity的Application？

- 抛异常强制退出：该方法通过抛异常，使程序Force Close。 

  android.os.Process.killProcess(android.os.Process.myPid());

- 记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。

  	List<Activity> lists = new LinkedList<Activity>();
  	lists.add(this);
  	for(Activity activity: lists)	{
  		activity.finish();
  	}
  	ondestory(){
  		lists.remove(this);
  	}

- 发送特定广播
- 递归退出

---

### service ###

>#### 6. Android启动Service的两种方式是什么? 它们的适用情况是什么 ####

- startService：生命周期与调用者不同。启动后若调用者未调用stopService而直接退出，Service仍会运行
- bindService：生命周期与调用者绑定，调用者一旦退出，Service就会调用unBind->onDestroy

> #### 7. 什么是IntentService？有何优点？

可以通过`startService(intent)`来提交请求，该服务会需要时自动创建，当完成任务时自动关闭。

案例：1上传图片。上传完成发送广播完成信息反馈、

```Java
含有抽象方法，onHandleIntent。可以处理异步操作
@WorkerThread
protected abstract void onHandleIntent (Intent intent);
```

### contentProvider ###
> #### 8. ContentProvider是如何实现数据共享的。
> ​        ContentResolver: 当一个程序需要把数据暴露给其它程序时，就可以使用contentProvider实现。其他程序可用过contentResolver来操作contentProvider暴露的数据。
> ​      其它程序访问本程序的数据，无需关心程序时候启动。都能实现对暴露数据的增删改查。
> ​       ContentProvider以Uri的形式暴露数据。其他程序使用Uri即可操作指定数据。
> 步骤：
1. 定义自己的ContentProvider类，该类需要继承Android提供的ContentProvider基类。
2. 在AndroidManifest.xml文件中注册个ContentProvider，注册ContenProvider时需要为它绑定一个URL。例如：`android:authorities="com.myit.providers.MyProvider" `authorities属性指定的Uri。
3. 接下就是获取这些数据了，Context提供了如下方法来获取ContentResolver对象。一般来说，ContentProvider是单例模式，当多个应用程序通过ContentResolver来操作 ContentProvider提供的数据时，ContentResolver调用的数据操作将会委托给同一个ContentProvider处理。使用ContentResolver操作数据只需两步：
   1、调用Activity的ContentResolver获取ContentResolver对象。
   2、根据需要调用ContentResolver的insert()、delete()、update()和query（）方法操作数据即可。
###  BroadCastReceiver

> #### 9. BroadCastReceiver的安全性，如何解决 ?

BroadCast的设计初衷是为全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：
1. 发送广播时，系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配。可以通过`sendBroadcast(Intent, String)`指定接受者的权限，或者`intent.setPackage()指定在某个应用中有效。`
2. 注册广播时，动态注册可以通过`segisterReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)`的接口指定发送者必须具备的permission。静态注册可以通过`android:exported="false"`不解释其他程序的广播。
3. 使用`LocalBroadcastManager`
   - 因广播数据在本应用范围内传播，你不用担心隐私数据泄露的问题。
   - 不用担心别的应用伪造广播，造成安全隐患。
   - 相比在系统内发送全局广播，它更高效。
```java
mLocalBroadcastManager = LocalBroadcastManager.getInstance(this);  
mLocalBroadcastManager.registerReceiver(mReceiver, filter);  
```

### 对Context的理解

[Android中Context详解](http://blog.csdn.net/qinjuning/article/details/7310620)

[Android Context完全解析，你所不知道的Context的各种细节](http://blog.csdn.net/guolin_blog/article/details/47028975)

## 技术点：熟练使用Support Design labrary的控件

[AndroidSupportDesign使用详解](http://blog.csdn.net/eclipsexys/article/details/46349721)

[Android Design Support Library 的 代码实验](http://www.jianshu.com/p/1078568e859f)

[Context到底是什么？](http://www.jianshu.com/p/94e0f9ab3f1d)

## 技术点：内存相关

> #### Android 虚拟机什么时候进行GC

- 根搜索算法：Android虚拟机的垃圾回收采用的是`根搜索算法`。GC会从根节点（GC Roots）开始对heap进行遍历。到最后，部分没有直接或者间接引用到GC Roots的就是需要回收的垃圾，会被GC回收掉。

[Android内存泄漏研究](http://jiajixin.cn/2015/01/06/memory_leak/)

> #### 8. StrongReference、WeakReference和SoftReference的区别？

- 强引用是普遍存在的，类是`Object obj = new Object();` 只要引用存在，Gc就不会回收该类应用
- 软引用用来描述一些有用但非必须的对象，对于软引用关联着的对戏那个，在系统将要发生内存溢出异常时，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收的还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了`SoftReference类来实现软引用`。
- 弱引用用来描述非必须的对象，但是它的强度比软引用更软一点，被弱引用关联的对象只能生存到下一次GC发生之前，当GC工作时，无论内存时候够用，都是回收弱应用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。
- 虚引用。它是最弱的一个引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是在这个对象被GC回收是收到一个系统通知。在JDK 1.2之后提供了PhantomReference类来实现虚引用。


> #### 9. 在Android中，怎么节省内存的使用，怎么主动回收内存？
1. 回收已经使用的资源,  
2. 合理的使用缓存
3. 合理设置变量的作用范围…  application 对象 。`System.gc()`;//未来的某一段时间执行  

>#### 10 内存泄露的场景举例

- cursor对象为关闭。
- 不使用convertView 
- Bitmap对象不再使用时调用recycle()释放内存 (高版本自动释放)
- 无用时没有释放对象的引用 
- 在Activity中使用非静态的内部类，并开启一个长时间运行的线程，因为内部类持有Activity的引用，会导致Activity本来可以被gc时却长期得不到回收
- 使用Handler处理消息前，Activity通过例如finish()退出，导致内存泄漏 
- 动态注册广播在Activity销毁前没有unregisterReceiver

>#### 11 Java带垃圾回收的机制,为什么还会内存泄露呢?

Java 内存泄露的根本原因就是 ：`保存了不可能再被访问的变量类型的引用`
```Java
Vector v = new Vector(10);     
for (int i = 1; i < 100; i++){    
	Object o = new Object();      　
    v.add(o);      　
	o = null;      
}//此时，所有的Object对象都没有被释放，因为变量v引用这些对象
```
###  Linux

>#### 12 简单的linux命令

cat ls ps psw wc mv rm cd ping tracert find grep tail vi gcc make ifconfig
startup dhcp

> ####  13 dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念

Dvm的进程是dalivk虚拟机进程,每个android程序都运行在自己的进程里面,
每个android程序系统都会给他分配一个单独的liunx  uid(user id), 
每个dvm都是linux里面的一个进程.所以说这两个进程是一个进程.

> #### 14. 描述Android的四层体系架构

Android体系架构，可以分为四层，分别是，Linux  Kernel，Libraries，Applocation framework，Application。

- Linux Kernel是Linux内核层，包含了各种硬件驱动。 Display Device，Carame Decive，Audio Device...Binder（IPC）进程间通信机制。
- Libraries & Runtime。c/c++库：包括webkit，freetype，SSL，SGL，SQLite。Runtime，指向字节码文件。
- Application framework：开发相关
- Application：面向用户，即应用程序。

###  Jni

> JNI调用常用的两个参数

`JNIEnv *env`, `jobject javaThis`

### View

> 11  Android UI中的View如何刷新。

`view.invalidate();`主线程
`view.postInvalidate();`子线程

> #### 12. 自定义View的步骤

为了满足我们自己正需和别人不一样的效果，这就需我们自定义控件。

- 明确需要，确定想要实现的效果。
- 组合控件，继承viewgroup例如自定义titlebar、settingitem
- 自定义view，考虑继承TextView，ImageView，还是View。
- 根据需要去复写View#onDraw、View#onMeasure、View#onLayout方法


- 根据需要去复写dispatchTouchEvent、onTouchEvent方法


- 根据需要为你的自定义view提供自定义属性，即编写attr.xml,然后在代码中通过TypedArray等类获取到自定义属性值


- 需要处理滑动冲突、像素转换等问题


-----

## 技术点异步消息处理机制

> #### 请介绍下AsyncTask的内部实现，适用的场景是

AsyncTask内部也是Handler机制来完成的，只不过Android提供了执行框架来提供线程池来执行相应地任务，因为线程池的大小问题，所以AsyncTask只应该用来执行耗时时间较短的任务，比如HTTP请求，大规模的下载和数据库的更改不适用于AsyncTask，因为会导致线程池堵塞，没有线程来执行其他的任务，导致的情形是会发生AsyncTask根本执行不了的问题。

## View事件传递机制

## Android启动过程



## JVM，ART和Dalvik虚拟机的区别？

jvm，即Java virtual machine。Java程序经过编译生成.class 字节码文件，这些class文件直接运行在JVM上。

Dalvik，是Android 5.0之前使用的虚拟机。apk文件在打包的时候会生成一个.dex文件，每次android程序运行时，都会将该.dex文件即时翻译成机器码文件。指定效率不高。而Anr的出现解决了这一问题。

ART，在5.0之后Android全部替换掉了Dalvik，它在apk文件安装的时候会预先将.dex字节码文件翻译成机器码，这个机器码文件为.oat文件，它是能直接在硬件上运行的，这样使得android程序执行效率大大提升。但是确定就是增加了内存空间的消耗，但是对于性能的提升，还是值得消耗这点内存的。

## Http网络相关协议

Http基础知识[我们需要掌握的Http](http://www.jianshu.com/p/e544b7a76dac)

